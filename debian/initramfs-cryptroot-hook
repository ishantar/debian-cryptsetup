#!/bin/sh

PREREQ=""
KEYSCRIPT="/sbin/cryptgetpw"

prereqs()
{
	echo "$PREREQ"
}

case $1 in
prereqs)
	prereqs
	exit 0
	;;
esac

. /usr/share/initramfs-tools/hook-functions

get_root_device() {
	[ -r /etc/fstab ] || return

	grep '^[^#]' /etc/fstab | ( \
	while read device mount type options dump pass; do
		if [ "$mount" = "/" ]; then
			echo "$device"
			return
		fi
	done )
}

node_is_in_crypttab() {
	local node
	node=$1
	
	grep -q ^$node /etc/crypttab
	return $?
}

get_lvm_device() {
	local node deps maj min
	node="$1"

	[ -z $node ] && return

	deps=$(dmsetup deps "$node" 2> /dev/null | \
		sed -e 's/.*://;s/[ (]//g;s/)/ /g')
	# Deps can only contain one major/minor pair since dm-crypt is a
	# one-to-one mapping, but let's make sure
	if [ $(echo "$deps" | wc -w) -ne 1 ]; then
		echo "$0: failed to parse device-mapper dependencies" >&2
		exit 1
	fi
	maj=$(echo "$deps" | cut -d',' -f1)
	min=$(echo "$deps" | cut -dÍ„',' -f2)

	# dmsetup info will error out if the underlying device is not a
	# device-mapper device (e.g. /dev/hda1). This is not an error, it
	# just means we are not using crypto on top of LVM
	depnode=$(dmsetup info -c --noheadings -j$maj -m$min 2> /dev/null | \
		cut -d':' -f 1) && echo "$depnode"
	return 0
}

get_root_opts() {
	local target source extraopts rootopts opt
	target=$1
	extraopts=$2

	[ ! -z $target ] || return
	[ -r /etc/crypttab ] || return

	opt=$( grep ^$target /etc/crypttab | head -1 | sed 's/[[:space:]]\+/ /g' )
	source=$( echo $opt | cut -d " " -f2 )
	key=$( echo $opt | cut -d " " -f3 )
	rootopts=$( echo $opt | cut -d " " -f4- )

	[ ! -z "$opt" -a ! -z "$source" -a ! -z "$rootopts" ] || return 1
	[ ! -z "$extraopts" ] && rootopts="${extraopts},${rootopts}"

	# We have all the basic options, let's go trough them
	echo -n "target=$target,source=$source"
	local IFS=", "
	for opt in $rootopts; do
		case $opt in
			cipher=*)
				echo -n ",$opt"
				;;
			hash=*)
				echo -n ",$opt"
				;;
			size=*)
				echo -n ",$opt"
				;;
			lvm=*)
				echo -n ",$opt"
				;;
			keyscript=*)
				echo -n ",key=$key"
				KEYSCRIPT=${opt#keyscript=}
				;;
			*)
				# Presumably a non-supported option
				;;
		esac
	done
}

get_root_modules() {
	local rootnode value cipher ivhash
	rootnode=$1

	# Check the ciphers used by the active root mapping
	value=$( dmsetup table $rootnode | cut -d " " -f4 )

	cipher=$( echo $value | cut -d ":" -f1 | cut -d "-" -f1 )
	[ -z "$cipher" ] && return
	echo $cipher

	ivhash=$( echo $value | cut -d ":" -s -f2 )
	[ ! -z "$ivhash" ] && echo "$ivhash"
}

# Unless MODULES = "dep", we always add a basic subset of modules/tools
if [ "$MODULES" != "dep" ]; then
	for mod in dm_mod dm_crypt aes sha256; do
		manual_add_modules $mod
	done
	copy_exec /sbin/cryptsetup /sbin
	copy_exec /sbin/dmsetup /sbin
fi

# Find out which device root is on
rootdev=$(get_root_device)
if [ -z "$rootdev" ]; then
	exit 0
fi

# Check that it is a node under /dev/mapper/
node="${rootdev#/dev/mapper/}"
if [ "$node" != "$rootdev" ]; then
	exit 0
fi

# Can we find this node in crypttab
opts=""
if ! node_is_in_crypttab "$node"; then
	# It is a /dev/mapper node but not in crypttab, is it lvm?
	lvmtest=$(get_lvm_device "$node")

	if [ -z "$lvmtest" ]; then
		# Neither in crypttab, nor a lvm device, our work is done
		exit 0
	else
		# It is a lvm device!
		opts="lvm=$node"
		node="$lvmtest"
	fi
fi

# Get crypttab root options
rootopts=$(get_root_opts $node $opts)
if [ -z "$rootopts" ]; then
	echo "$0: failed to determine cipher options to use"
	exit 1
fi

# Calculate needed modules
force_load dm_mod
force_load dm_crypt
modules=$(get_root_modules $node | sort | uniq)
if [ -z "$modules" ]; then
	echo "$0: failed to determine cipher modules to load" >&2
	exit 1
fi
for mod in $modules; do
	manual_add_modules $mod
done

# Prepare the initramfs
echo "CRYPTOPTS=\"$rootopts\"" > ${DESTDIR}/conf/conf.d/cryptroot
copy_exec /sbin/cryptsetup /sbin
copy_exec /sbin/dmsetup /sbin

# If we have a keyscript, make sure it is included
if [ -x "$KEYSCRIPT" ]; then
	copy_exec "$KEYSCRIPT" /sbin

	# Make sure that the script is called cryptgetpw
	BNAME=$(basename "$KEYSCRIPT")
	if [ "$BNAME" != "cryptgetpw" ]; then
		mv $DESTDIR/sbin/$BNAME $DESTDIR/sbin/cryptgetpw
	fi
fi

# Allow the correct keymap to be loaded if possible
if [ -x /bin/loadkeys -a -r /etc/console/boottime.kmap.gz ]; then
	copy_exec /bin/loadkeys /bin/
	cp /etc/console/boottime.kmap.gz $DESTDIR/etc/

	# Check for UTF8 console
	ENV_FILE="none"
	[ -r /etc/environment ] && ENV_FILE="/etc/environment"
	[ -r /etc/default/locale ] && ENV_FILE="/etc/default/locale" 

	if [ $ENV_FILE != none ]; then
		for var in LANG LC_ALL LC_CTYPE; do
			value=$(egrep "^[^#]*${var}=" $ENV_FILE | tail -n1 | cut -d= -f2)
			eval $var=$value
		done

		CHARMAP=`LANG=$LANG LC_ALL=$LC_ALL LC_CTYPE=$LC_CTYPE locale charmap`
		if [ "$CHARMAP" = "UTF-8" -a -x /usr/bin/kbd_mode ]; then
			copy_exec /usr/bin/kbd_mode /bin/
		fi
	fi
fi

# Done
exit 0
