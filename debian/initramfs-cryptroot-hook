#!/bin/sh

PREREQ=""

prereqs()
{
	echo "$PREREQ"
}

case $1 in
prereqs)
	prereqs
	exit 0
	;;
esac

. /usr/share/initramfs-tools/hook-functions

get_root_device() {
	if [ ! -r /etc/fstab ]; then
		return 1
	fi

	grep '^[^#]' /etc/fstab | \
	while read device mount type options dump pass; do
		if [ "$mount" = "/" ]; then
			echo "$device"
			return
		fi
	done
}

get_resume_devices() {
	local device opt

	# uswsusp
	if [ -e /etc/uswsusp.conf ]; then
		device=$(sed -rn 's/^resume device[[:space:]]+[:=][[:space:]]+// p' /etc/uswsusp.conf)
		if [ -n "$device" ]; then
			echo "$device"
		fi
	fi

	# regular swsusp
	for opt in $(cat /proc/cmdline); do
		case $opt in
		resume=*)
			echo "${opt#resume=}"
			;;
		esac
	done
}

node_is_in_crypttab() {
	local node
	node="$1"

	grep -q ^$node /etc/crypttab
	return $?
}

get_lvm_deps() {
	local node rc deps maj min depnode
	node="$1"
	rc=1

	if [ -z $node ]; then
		return $rc
	fi

	deps=$(dmsetup deps "$node" | sed 's/[^:]*: *//;s/[ (]//g;s/)/ /g') || return 1

	for dep in $deps; do
		maj=${dep%,*}
		min=${dep#*,}
		depnode=$(dmsetup ls | sed -n "s/\\([^ ]*\\) *($maj, $min)/\\1/p")
		if [ -n "$depnode" ]; then
			echo "$depnode"
			rc=0
		fi
	done

	return $rc
}

get_device_opts() {
	local target source extraopts rootopts opt
	target="$1"
	extraopts="$2"
	KEYSCRIPT=""
	OPTIONS=""

	if [ -z "$target" ]; then
		return 1
	fi

	if [ ! -r /etc/crypttab ]; then
		return 1
	fi

	opt=$( grep ^$target /etc/crypttab | head -1 | sed 's/[[:space:]]\+/ /g' )
	source=$( echo $opt | cut -d " " -f2 )
	key=$( echo $opt | cut -d " " -f3 )
	rootopts=$( echo $opt | cut -d " " -f4- )

	if [ -z "$opt" ] || [ -z "$source" ] || [ -z "$key" ] || [ -z "$rootopts" ]; then
		return 1
	fi

	if [ -n "$extraopts" ]; then
		rootopts="$extraopts,$rootopts"
	fi

	# We have all the basic options, let's go trough them
	OPTIONS="target=$target,source=$source,key=$key"
	local IFS=", "
	for opt in $rootopts; do
		case $opt in
			cipher=*)
				OPTIONS="$OPTIONS,$opt"
				;;
			hash=*)
				OPTIONS="$OPTIONS,$opt"
				;;
			size=*)
				OPTIONS="$OPTIONS,$opt"
				;;
			lvm=*)
				OPTIONS="$OPTIONS,$opt"
				;;
			keyscript=*)
				opt=${opt#keyscript=}
				if [ -x "$opt" ]; then
					KEYSCRIPT="$opt"
					opt=$(basename "$opt")
					OPTIONS="$OPTIONS,keyscript=/keyscripts/$opt"
				fi
				;;
			*)
				# Presumably a non-supported option
				;;
		esac
	done
}

get_device_modules() {
	local node value cipher ivhash
	node="$1"

	# Check the ciphers used by the active root mapping
	value=$(dmsetup table "$node" | cut -d " " -f4)
	cipher=$(echo "$value" | cut -d ":" -f1 | cut -d "-" -f1)
	ivhash=$(echo "$value" | cut -d ":" -s -f2)

	if [ -z "$cipher" ]; then
		return 1
	fi

	echo "$cipher"

	if [ -n "$ivhash" ]; then
		echo "$ivhash"
	fi
	return 0
}

prepare_keymap() {
	local env charmap

	# Allow the correct keymap to be loaded if possible
	if [ ! -x /bin/loadkeys ] || [ ! -r /etc/console/boottime.kmap.gz ]; then
		return 1
	fi

	copy_exec /bin/loadkeys /bin/
	cp /etc/console/boottime.kmap.gz $DESTDIR/etc/

	# Check for UTF8 console
	if [ ! -x /usr/bin/kbd_mode ]; then
		return 0
	fi

	if [ -r /etc/environment ]; then
		env="/etc/environment"
	elif [ -r /etc/default/locale ]; then
		env="/etc/default/locale"
	else
		return 0
	fi

	for var in LANG LC_ALL LC_CTYPE; do
		value=$(egrep "^[^#]*${var}=" $env | tail -n1 | cut -d= -f2)
		eval $var=$value
	done

	charmap=$(LANG=$LANG LC_ALL=$LC_ALL LC_CTYPE=$LC_CTYPE locale charmap)
	if [ "$charmap" = "UTF-8" ]; then
		copy_exec /usr/bin/kbd_mode /bin/
	fi
	return 0
}

add_device() {
	local node nodes opts lastopts i count
	nodes="$1"
	opts=""     # Applied to all nodes
	lastopts="" # Applied to last node

	if [ -z "$nodes" ]; then
		return 0
	fi

	# Check that it is a node under /dev/mapper/
	nodes="${nodes#/dev/mapper/}"
	if [ "$nodes" = "$1" ]; then
		return 0
	fi

	# Can we find this node in crypttab
	if ! node_is_in_crypttab "$nodes"; then
		# It is a /dev/mapper node but not in crypttab, is it lvm?
		lvmnodes=$(get_lvm_deps "$nodes") || return 1

		# It is a lvm device!
		lastopts="lvm=$nodes"
		nodes="$lvmnodes"
	fi

	# Prepare to setup each node
	count=$(echo "$nodes" | wc -w)
	i=1
	for node in $nodes; do
		# Prepare the additional options
		if [ $i -eq $count ]; then
			if [ -z "$opts" ]; then
				opts="$lastopts"
			else
				opts="$opts,$lastopts"
			fi
		fi

		# Get crypttab root options
		if ! get_device_opts $node $opts; then
			echo "cryptsetup: failed to determine cipher options to use for $node" >&2
			continue
		fi
		echo "$OPTIONS" >> "$DESTDIR/conf/conf.d/cryptroot"

		# If we have a keyscript, make sure it is included
		if [ -n "$KEYSCRIPT" ]; then
			if [ ! -d "$DESTDIR/keyscripts" ]; then
				mkdir "$DESTDIR/keyscripts"
			fi
			copy_exec "$KEYSCRIPT" /keyscripts
		fi

		# Calculate needed modules
		modules=$(get_device_modules $node | sort | uniq)
		if [ -z "$modules" ]; then
			echo "$0: failed to determine cipher modules to load for $node" >&2
			continue
		fi
		echo dm_mod
		echo dm_crypt
		echo "$modules"

		i=$(( $i + 1 ))
	done

	return 0
}


#
# Begin real processing
#

# Unless MODULES = "dep", we always add a basic subset of modules/tools
if [ "$MODULES" != "dep" ]; then
	for mod in dm_mod dm_crypt aes sha256; do
		manual_add_modules $mod
	done
	copy_exec /sbin/cryptsetup /sbin
	copy_exec /sbin/dmsetup /sbin
	prepare_keymap
fi

# Find out which devices to add to the config file
rootdev=$(get_root_device)
resumedevs=$(get_resume_devices)
if [ -z "$rootdev" ] && [ -z "$resumedevs" ]; then
	exit 0
fi

# Load the config opts and modules for each device
for dev in $rootdev $resumedevs; do
	modules=$(add_device "$dev")

	if [ -z "$modules" ]; then
		echo "cryptsetup: failed to determine cipher modules to load for $dev" >&2
		exit 1
	fi

	for mod in $modules; do
		manual_add_modules $mod
	done
done

# Prepare the initramfs
copy_exec /sbin/cryptsetup /sbin
copy_exec /sbin/dmsetup /sbin
prepare_keymap

# Done
exit 0
