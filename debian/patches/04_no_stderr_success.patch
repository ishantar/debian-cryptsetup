## 04_no_sterr_success.patch
## by Jonas Meurer <jonas@freesources.org>
##
## adds a commandline option to suppress the success message to stderr.
## some minor formating fixes.

--- a/man/cryptsetup.8
+++ b/man/cryptsetup.8
@@ -133,7 +133,7 @@
 The number of milliseconds to spend with PBKDF2 password processing. This option is only relevant to the LUKS operations as \fIluksFormat\fR or \fIluksAddKey\fR.
 .TP
 .B "\-\-batch-mode, \-q"
-Do not ask for confirmation. Use with care! This option is only relevant for \fIluksFormat\fR,\fIluksAddKey\fR,\fIluksRemoveKey\fR or \fIluksKillSlot\fR.
+Do not ask for confirmation. Use with care! This option is only relevant for \fIluksFormat\fR, \fIluksAddKey\fR, \fIluksRemoveKey\fR or \fIluksKillSlot\fR.
 .TP
 .B "\-\-timeout, \-t"
 The number of seconds to wait before timeout. This option is relevant every time a password is asked, like \fIcreate\fR, \fIluksOpen\fR, \fIluksFormat\fR or \fIluksAddKey\fR. It has no effect if used in conjunction with \-\-key-file.
@@ -146,6 +146,9 @@
 useful to align the filesystem at full stripe boundaries so it can take advantage of the RAID's geometry.  See for instance the sunit and swidth options
 in the mkfs.xfs manual page. By default, the payload is aligned at an 8 sector (4096 byte) boundary.
 .TP
+.B "\-\-no-stderr-success"
+Do not print success message '\fICommand successfull\fR' to stderr.
+.TP
 .B "\-\-version"
 Show the version.
 
--- a/src/cryptsetup.c
+++ b/src/cryptsetup.c
@@ -32,6 +32,7 @@
 static int opt_tries = 3;
 static int opt_align_payload = 0;
 static int opt_non_exclusive = 0;
+static int opt_no_stderr_success = 0;
 
 static const char **action_argv;
 static int action_argc;
@@ -126,7 +127,8 @@
 	char error[256];
 
 	if(!errcode) {
-                fprintf(stderr, _("Command successful.\n"));
+                if (!opt_no_stderr_success)
+			fprintf(stderr, _("Command successful.\n"));
                 return;
 	}
 
@@ -461,19 +463,19 @@
 		{ "verify-passphrase", 'y',  POPT_ARG_NONE,                               &opt_verify_passphrase, 0, N_("Verifies the passphrase by asking for it twice"),                  NULL },
 		{ "key-file",          'd',  POPT_ARG_STRING,                             &opt_key_file,          0, N_("Read the key from a file (can be /dev/random)"),                   NULL },
 		{ "key-size",          's',  POPT_ARG_INT    | POPT_ARGFLAG_SHOW_DEFAULT, &opt_key_size,          0, N_("The size of the encryption key"),                                  N_("BITS") },
-		{ "key-slot",          'S',  POPT_ARG_INT,                                &opt_key_slot,          0, N_("Slot number for new key (default is first free)"),      NULL },
+		{ "key-slot",          'S',  POPT_ARG_INT,                                &opt_key_slot,          0, N_("Slot number for new key (default is first free)"),                 NULL },
 		{ "size",              'b',  POPT_ARG_STRING,                             &popt_tmp,              1, N_("The size of the device"),                                          N_("SECTORS") },
 		{ "offset",            'o',  POPT_ARG_STRING,                             &popt_tmp,              2, N_("The start offset in the backend device"),                          N_("SECTORS") },
 		{ "skip",              'p',  POPT_ARG_STRING,                             &popt_tmp,              3, N_("How many sectors of the encrypted data to skip at the beginning"), N_("SECTORS") },
 		{ "readonly",          'r',  POPT_ARG_NONE,                               &opt_readonly,          0, N_("Create a readonly mapping"),                                       NULL },
-		{ "iter-time",         'i',  POPT_ARG_INT,                                &opt_iteration_time,    0, N_("PBKDF2 iteration time for LUKS (in ms)"),
-		  N_("msecs") },
+		{ "iter-time",         'i',  POPT_ARG_INT,                                &opt_iteration_time,    0, N_("PBKDF2 iteration time for LUKS (in ms)"),                          N_("msecs") },
 		{ "batch-mode",        'q',  POPT_ARG_NONE,                               &opt_batch_mode,        0, N_("Do not ask for confirmation"),                                     NULL },
-		{ "version",        '\0',  POPT_ARG_NONE,                                 &opt_version_mode,        0, N_("Print package version"),                                     NULL },
+		{ "version",           '\0', POPT_ARG_NONE,                               &opt_version_mode,      0, N_("Print package version"),                                           NULL },
  		{ "timeout",           't',  POPT_ARG_INT,                                &opt_timeout,           0, N_("Timeout for interactive passphrase prompt (in seconds)"),          N_("secs") },
   		{ "tries",             'T',  POPT_ARG_INT,                                &opt_tries,             0, N_("How often the input of the passphrase can be retried"),            NULL },
- 		{ "align-payload",     '\0',  POPT_ARG_INT,                               &opt_align_payload,     0, N_("Align payload at <n> sector boundaries - for luksFormat"),         N_("SECTORS") },
- 		{ "non-exclusive",     '\0',  POPT_ARG_NONE,                              &opt_non_exclusive,     0, N_("Allows non-exclusive access for luksOpen, WARNING see manpage."),        NULL },
+ 		{ "align-payload",     '\0', POPT_ARG_INT,                                &opt_align_payload,     0, N_("Align payload at <n> sector boundaries - for luksFormat"),         N_("SECTORS") },
+ 		{ "non-exclusive",     '\0', POPT_ARG_NONE,                               &opt_non_exclusive,     0, N_("Allows non-exclusive access for luksOpen, WARNING see manpage."),  NULL },
+		{ "no-stderr-success", '\0', POPT_ARG_NONE,                               &opt_no_stderr_success, 0, N_("Do not print success message to stderr"),                          NULL },
 		POPT_TABLEEND
 	};
 	poptContext popt_context;
