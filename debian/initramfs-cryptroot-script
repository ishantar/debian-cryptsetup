#!/bin/sh

#
# Standard initramfs preamble
#
prereqs()
{
	# Make sure that cryptroot is run last in local-top
	for req in /scripts/local-top/*; do
		script=$(basename $req)
		[ $script != cryptroot ] && echo $script
	done
}

case $1 in
prereqs)
	prereqs
	exit 0
	;;
esac


#
# Helper functions
#
get_options()
{
	# Do we have any settings from the /conf/conf.d/cryptroot file?
	[ -r /conf/conf.d/cryptroot ] && . /conf/conf.d/cryptroot
	cryptopts="${CRYPTOPTS}"

	# Does the kernel boot command line override them?
	for x in $(cat /proc/cmdline); do
		case $x in
		cryptopts=*)
			cryptopts=${x#cryptopts=}
			;;
		esac
	done

	# Sanity check
	if [ -z "$cryptopts" ]; then
		# Apparently the root partition isn't encrypted
		echo "No cryptroot configured, skipping"
		exit 0
	fi

	# There are two possible scenarios here:
	#
	# 1) The fstype of the root device has been identified as "luks"
	# 2) The fstype is not "luks" but cryptopts has been set
	#
	# The former means that we use the luks functionality of cryptsetup, the
	# latter means that we do it the old-fashioned way.
	#
	# Start by parsing some options, all options are relevant to regular cryptsetup
	# but only crypttarget and cryptsource is relevant to luks which picks up the 
	# rest of the parameters by reading the partition header
	cryptcipher=aes-cbc-essiv:sha256
	cryptsize=256
	crypthash=sha256
	crypttarget=cryptroot
	cryptsource=$ROOT
	cryptlvm=""

	if [ -n "$cryptopts" ]; then
		local IFS=" ,"
		for x in $cryptopts; do
			case $x in
			hash=*)
				crypthash=${x#hash=}
				;;
			size=*)
				cryptsize=${x#size=}
				;;
			cipher=*)
				cryptcipher=${x#cipher=}
				;;
			target=*)
				crypttarget=${x#target=}
				;;
			source=*)
				cryptsource=${x#source=}
				;;
			lvm=*)
				cryptlvm=${x#lvm=}
				;;
			esac
		done
	fi
}

setup_lvm()
{
	local cryptlvm
	cryptlvm=$1

	if [ -z "$cryptlvm" ]; then
		panic "found lvm pv on encrypted device but no lvm option set"
	fi
	NEWROOT="/dev/mapper/${cryptlvm}"
	# Split volume group from logical volume.
	cryptlvm=$(echo ${cryptlvm} | sed -e 's#\(.*\)\([^-]\)-[^-].*#\1\2#')
	# Reduce padded --'s to -'s
	cryptlvm=$(echo ${cryptlvm} | sed -e 's#--#-#g')
	vgchange -ay ${cryptlvm}
	if ! fstype < "$NEWROOT" > /conf/param.conf; then
		panic "failed to setup lvm device, fs not recognised"
	fi
	. /conf/param.conf
}


#
# Begin real processing
#

# define crypto variables
get_options
if /sbin/cryptsetup isLuks $cryptsource > /dev/null 2>&1; then
	cryptcreate="/sbin/cryptsetup luksOpen $cryptsource $crypttarget"
	cryptremove=""
else
	cryptcreate="/sbin/cryptsetup -c $cryptcipher -s $cryptsize -h $crypthash create $crypttarget $cryptsource"
	cryptremove="/sbin/cryptsetup remove $crypttarget"
fi
NEWROOT="/dev/mapper/$crypttarget"

# Loop until we have a satisfactory password
while [ 1 ]; do
	if [ -x "/sbin/cryptgetpw" ]; then
		/sbin/cryptgetpw < /dev/console | $cryptcreate
	else
		$cryptcreate < /dev/console
	fi

	if [ $? -eq 0 ] && fstype < "$NEWROOT" > /conf/param.conf; then
		. /conf/param.conf
		[ "$FSTYPE" = "lvm" ] && setup_lvm "$cryptlvm"
		[ "$FSTYPE" != "unknown" ] && break
	fi

	echo "$0: cryptsetup failed or fstype not recognized, bad password or options?"
	$cryptremove
	sleep 3
done

# init can now pick up new FSTYPE, FSSIZE and ROOT
echo "ROOT=\"$NEWROOT\"" >> /conf/param.conf
exit 0
