#!/bin/sh

#
# Standard initramfs preamble
#
prereqs()
{
	# Make sure that cryptroot is run last in local-top
	for req in /scripts/local-top/*; do
		script=$(basename $req)
		if [ $script != cryptroot ]; then
			echo $script
		fi
	done
}

case $1 in
prereqs)
	prereqs
	exit 0
	;;
esac


#
# Helper functions
#
get_options()
{
	local CRYPTOPTS

	# Do we have any settings from the /conf/conf.d/cryptroot file?
	if [ -r /conf/conf.d/cryptroot ]; then
		. /conf/conf.d/cryptroot
	fi

	# Sanity check
	if [ -z "$CRYPTOPTS" ]; then
		# Apparently the root partition isn't encrypted
		echo "No cryptroot configured, skipping"
		exit 0
	fi

	# There are two possible scenarios here:
	#
	# 1) The fstype of the root device has been identified as "luks"
	# 2) The fstype is not "luks" but cryptopts has been set
	#
	# The former means that we use the luks functionality of cryptsetup, the
	# latter means that we do it the old-fashioned way.
	#
	# Start by parsing some options, all options are relevant to regular cryptsetup
	# but only crypttarget and cryptsource is relevant to luks which picks up the 
	# rest of the parameters by reading the partition header
	cryptcipher=aes-cbc-essiv:sha256
	cryptsize=256
	crypthash=sha256
	crypttarget=cryptroot
	cryptsource=$ROOT
	cryptlvm=""
	# This is only used as an argument to an eventual keyscript
	cryptkey=""

	local IFS=" ,"
	for x in $CRYPTOPTS; do
		case $x in
		hash=*)
			crypthash=${x#hash=}
			;;
		size=*)
			cryptsize=${x#size=}
			;;
		cipher=*)
			cryptcipher=${x#cipher=}
			;;
		target=*)
			crypttarget=${x#target=}
			;;
		source=*)
			cryptsource=${x#source=}
			;;
		lvm=*)
			cryptlvm=${x#lvm=}
			;;
		key=*)
			cryptkey=${x#key=}
			;;
		esac
	done
}

activate_vg()
{
	local vg
	vg=$1

	# Sanity checks
	if [ ! -x /sbin/vgchange ]; then
		return 1
	fi

	if [ -z "$vg" ]; then
		return 1
	fi

	# Make sure we're dealing with a lvm device
	vg=${vg#/dev/mapper/}
	if [ "$vg" = "$1" ]; then
		return 1
	fi

	# Make sure that the device contains at least one dash
	if [ "$(echo -n "$vg" | tr -d -)" = "$vg" ]; then
		return 1
	fi

	# Split volume group from logical volume.
	vg=$(echo ${vg} | sed -e 's#\(.*\)\([^-]\)-[^-].*#\1\2#')
	# Reduce padded --'s to -'s
	vg=$(echo ${vg} | sed -e 's#--#-#g')

	vgchange -ay ${vg}
	return $?
}

load_keymap()
{
	OPTS="-q"

	# Should terminal be in UTF8 mode?
	if [ -x /bin/kbd_mode ]; then
		/bin/kbd_mode -u
		OPTS="$OPTS -u"
	fi

	# Load custom keymap
	if [ -x /bin/loadkeys -a -r /etc/boottime.kmap.gz ]; then
		loadkeys $OPTS /etc/boottime.kmap.gz
	fi
}

#
# Begin real processing
#

# define crypto variables
get_options

# make sure the cryptsource device is available
if [ ! -e $cryptsource ]; then
	activate_vg $cryptsource
fi

if [ ! -e $cryptsource ]; then
	echo "$0: source device $cryptsource not found"
	exit 1
fi

# If possible, load the keymap so that the user can input non-en characters
load_keymap

# prepare commands
if /sbin/cryptsetup isLuks $cryptsource > /dev/null 2>&1; then
	cryptcreate="/sbin/cryptsetup luksOpen $cryptsource $crypttarget"
else
	cryptcreate="/sbin/cryptsetup -c $cryptcipher -s $cryptsize -h $crypthash create $crypttarget $cryptsource"
fi
cryptremove="/sbin/cryptsetup remove $crypttarget"
NEWROOT="/dev/mapper/$crypttarget"

# Loop until we have a satisfactory password
while [ 1 ]; do
	if [ -x "/sbin/cryptgetpw" ]; then
		/sbin/cryptgetpw $cryptkey < /dev/console | $cryptcreate
	else
		$cryptcreate < /dev/console
	fi

	FSTYPE=''
	if [ $? -ne 0 ]; then
		echo "$0: cryptsetup failed, bad password or options?"
	elif ! fstype < "$NEWROOT" > /conf/param.conf; then
		echo "$0: fstype not recognized, bad password or options?"
	else
		. /conf/param.conf

		# See if we need to setup lvm on the crypto device
		if [ "$FSTYPE" = "lvm" ] || [ "$FSTYPE" = "lvm2" ]; then
			NEWROOT="/dev/mapper/$cryptlvm"
			if ! activate_vg "$NEWROOT"; then
				echo "$0: failed to setup lvm device"
				exit 1
			fi
			if ! fstype < "$NEWROOT" > /conf/param.conf; then
				echo "$0: failed to setup lvm device, fs not recognised"
				exit 1
			fi
			. /conf/param.conf
		fi
	fi

	if [ -n "$FSTYPE" ] && [ "$FSTYPE" != "unknown" ]; then
		break
	fi

	if [ -e "$NEWROOT" ]; then
		$cryptremove
	fi
	sleep 3
done

# init can now pick up new FSTYPE, FSSIZE and ROOT
echo "ROOT=\"$NEWROOT\"" >> /conf/param.conf
exit 0
