# Bash command completion for cryptsetup

have cryptsetup &&
_cryptsetup()
{
    local cmd cur prev action actions luksactions argopts noargopts

    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    actions="create remove status reload resize"
    luksactions="luksFormat luksOpen luksClose luksAddKey luksDelKey luksUUID isLuks luksDump"
    actions="$luksactions $actions"

    argopts="-c --cipher -h --hash -d --key-file -s --key-size -b --size"
    argopts="$argopts -o --offset -p --skip -i --iter-time -q --batch-mode"
    argopts="$argopts -t --timeout -T --tries"
    noargopts="-y --verify-passphrase --readonly --version --align-payload"

    # complete file names for -d and --key-file
    if [ "-d" = "$prev" -o "--key-file" = "$prev" ] ; then
	COMPREPLY=( $(compgen -f -- "${cur}") )
    fi

    # If previous word was an option requiring an argument, can't complete
    for argopt in $argopts ; do
	if [ "$argopt" = "$prev" ] ; then
	    return
	fi
    done

    # If user typing an option, complete it
    if [[ $cur == -* ]] ; then
	COMPREPLY=( $(compgen -W "$argopts $noargopts" -- "$cur") )
	return
    fi

    # See if we already have an action
    action=""
    for word in "${COMP_WORDS[@]}" ; do
	for act in $actions ; do
	    if [ "$word" == "$act" ] ; then
		action=$act
		break
	    fi
	done

	if [ -n "$action" ] ; then
	    break
	fi
    done

    # No action yet, complete it
    if [ -z "$action" ] ; then
	COMPREPLY=( $(compgen -W "$actions" -- "$cur") )
	return
    fi

    # Completion based on action
    case "$action" in
	"create")
	    # create <name> <device>
	    if [ $COMP_CWORD -gt 1 ] &&
		[ ${COMP_WORDS[COMP_CWORD-2]} == "create" ] ; then
		COMPREPLY=( $(compgen -f -X '!/dev*' -- "$cur") )
	    fi
	;;

	"reload"|"remove"|"resize"|"status"|"luksClose")
	    # action <name>
	    MAPPINGS="$(command ls /dev/mapper | fgrep --invert-match control)"
	    OLDIFS="$IFS"
	    IFS="
"
	    COMPREPLY=( $(compgen -W "$MAPPINGS" -- "$cur") )
	    IFS="$OLDIFS"
	;;

	"luksDelKey")
	    # luksDelKey <name> <key slot number>
	    if [ ${COMP_WORDS[COMP_CWORD-1]} == "luksDelKey" ] ; then
		# Get name
		MAPPINGS="$(command ls /dev/mapper | fgrep --invert-match control)"
		OLDIFS="$IFS"
	    	IFS="
"
	    	COMPREPLY=( $(compgen -W "$MAPPINGS" -- "$cur") )
	    	IFS="$OLDIFS"
	    fi
	;;

	"luksAddKey"|"luksFormat")
	    # action <name> [<key file>]
	    if [ ${COMP_WORDS[COMP_CWORD-1]} == "luksFormat" ] ; then
		# Get name
		MAPPINGS="$(command ls /dev/mapper | fgrep --invert-match control)"
		OLDIFS="$IFS"
	    	IFS="
"
	    	COMPREPLY=( $(compgen -W "$MAPPINGS" -- "$cur") )
	    	IFS="$OLDIFS"
	    elif [ ${COMP_WORDS[COMP_CWORD-2]} == "luksFormat" ] ; then
		# Get key file
		COMPREPLY=( $(compgen -f -- "$cur") )
	    fi
	;;

	"luksOpen")
	    # luksOpen <device> <name>
	    if [ ${COMP_WORDS[COMP_CWORD-1]} == "luksOpen" ] ; then
		COMPREPLY=( $(compgen -f -X '!/dev*' -- "$cur") )
	    fi
	;;

	"isLuks"|"luksDump"|"luksUUID")
	    # action <device>
	    COMPREPLY=( $(compgen -f -X '!/dev*' -- "$cur") )
	;;
    esac
}
[ "$have" ] && complete -o filenames -F _cryptsetup cryptsetup

# vim:set filetype=sh sts=4 sw=4:
