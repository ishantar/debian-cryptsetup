CRYPTCMD=/sbin/cryptsetup
DEVMAPCMD=/sbin/dmsetup
LOSETUP=/sbin/losetup
TABFILE=/etc/crypttab
MAPPER=/dev/mapper

MOUNT="${CRYPTDISKS_MOUNT}"

test -x $CRYPTCMD  || exit 0
test -x $DEVMAPCMD || exit 0
test -f $TABFILE   || exit 0


parse_opts () {
	PARAMS=""
	CHECK=""
	CHECKARGS=""
	PRECHECK=""
	TRIES="3"
	MAKETMP=""
	MAKESWAP=""
	USELUKS=""
	SKIP=""
	TIMEOUT=""
	SSL=""
	GPG=""
	KEYSCRIPT=""

	# Parse the options field, convert to cryptsetup parameters
	# and construct the command line
	while test "x$opt" != "x" ; do
		ARG=`echo $opt | sed "s/,.*//"`
		opt=${opt##$ARG}
		opt=${opt##,}
		PARAM=`echo $ARG | sed "s/=.*//"`
		
		case "$ARG" in
		  *=*)
		  	PARAM=`echo $ARG | sed "s/=.*//"`
		  	VALUE=${ARG##$PARAM=}
		  	;;
		  *)
		  	PARAM=$ARG
		  	VALUE=""
			;;
		esac
		
		case "$PARAM" in 
		  readonly)
		  	PARAMS="$PARAMS -r"
		  	;;
		  cipher)
		  	PARAMS="$PARAMS -c $VALUE"
		  	if test "x$VALUE" = "x" ; then
		  		echo -e "\n - no value for cipher option, skipping" >&2
		  		SKIP="yes"
		  	fi
		  	;;
		  size)
		  	PARAMS="$PARAMS -s $VALUE"
		  	if test "x$VALUE" = "x" ; then
		  		echo -e "\n - no value for size option, skipping" >&2
		  		SKIP="yes"
		  	fi
		  	;;
		  hash)
		  	PARAMS="$PARAMS -h $VALUE"
		  	if test "x$VALUE" = "x" ; then
		  		echo -e "\n - no value for hash option, skipping" >&2
		  		SKIP=yes
		  	fi
		  	;;
		  verify)
		  	PARAMS="$PARAMS -y"
		  	;;
		  check)
		  	if test "x$VALUE" = "x" ; then
				CHECK="${CRYPTDISKS_CHECK}"
			else
		  		CHECK="$VALUE"
		  	fi
		  	if [ "$CHECK" -a -x /lib/cryptsetup/checks/"$CHECK" ]; then
		   		CHECK="/lib/cryptsetup/checks/$CHECK"
		  	#else
		  	#	CHECK=""
		  	fi
		  	;;
		  checkargs)
		  	if test "x$VALUE" != "x"; then
				CHECKARGS="$VALUE"
			fi
			;;
		  precheck)
		  	if test "x$VALUE" = "x" ; then
				PRECHECK="${CRYPTDISKS_PRECHECK}"
			else
		  		PRECHECK="$VALUE"
		  	fi
		   	if [ "$PRECHECK" -a -x /lib/cryptsetup/checks/"$PRECHECK" ]; then
		  		PRECHECK="/lib/cryptsetup/checks/$PRECHECK"
		  	else
		  		PRECHECK=""
		  	fi
		  	;;
		  tries)
		  	if test "x$VALUE" != "x" ; then
		  		TRIES="$VALUE"
		  	fi
		  	case "$TRIES" in
		  	  [0-9]*)
		  	  	;;
		  	  *)
			  	echo -e "\n - option TRIES is wrongly set to $TRIES - forced to '3' " >&2
			  	TRIES="3"
			  	;;
			esac
		  	PARAMS="$PARAMS --tries=$TRIES"
		  	;;
		  timeout)
		  	if test "x$VALUE" = "x" ; then
				TIMEOUT="${CRYPTDISKS_TIMEOUT}"
			else
		  		TIMEOUT="$VALUE"
		  	fi
			case "$TIMEOUT" in
			  [0-9]*)
			  	;;
			  *)
			  	echo -e "\n - option TIMEOUT is wrongly set to $TIMEOUT - forced to '0' " >&2
				TIMEOUT="0"
				;;
			esac
		  	PARAMS="$PARAMS --timeout=$TIMEOUT"
		  	;;
		  swap)
		  	MAKESWAP=yes
			SWCHECK="/lib/cryptsetup/checks/un_vol_id"
			SWCHECKARGS="swap"
		  	;;
		  tmp)
		  	MAKETMP=yes
		  	;;
		  luks)
		  	USELUKS=yes
			;;
		  loud)
		  	LOUD=yes
			;;
		  ssl)
		  	SSL=yes
			;;
		  gpg)
		  	GPG=yes
			;;
		  keyscript)
		  	if test "x$VALUE" = "x" ; then
		  		echo -e "\n - no value for keyscript option, skipping" >&2
		  		SKIP="yes"
		  	fi
			KEYSCRIPT="$VALUE"
		  	;;
		esac
	done

	if [ "$SSL" != "" -a "$GPG" != "" ]; then
		echo -e "\n - ssl and gpg options are not allowed together, skipping" >&2
		continue
	fi

	if test "x$SKIP" = "xyes" ; then
		continue
	fi
}

decrypt_ssl () {
	origumask=`umask`
	umask 077
	tmpkey=`tempfile`

	while ( ! /usr/bin/openssl enc -aes256 -d -salt -in $key -out $tmpkey \
	          -k $password > /dev/null 2>&1 ); do
		echo -en "\nSecond password for key $key: "
		read -s password <${CONSOLE:-/dev/tty}
		echo
		[ "$password" = "" ] && return 0
	done

	deckey=`tempfile`
	while ( ! /usr/bin/openssl dsa -in $tmpkey -out $deckey -passin \
	          pass:$password > /dev/null 2>&1 ); do
		echo -en "\nFirst password for key $key: "
		read -s password <${CONSOLE:-/dev/tty}
		echo
		[ "$password" = "" ] && return 0
	done

	password=""
	rm -f $tmpkey && tmpkey=""
	umask $origumask
}

decrypt_gpg () {
	origumask=`umask`
	umask 077
	deckey=`tempfile`

	echo -e "\n - gpg option is not implemented yet, skipping" >&2
	continue

	while ( ! echo $password | /usr/bin/gpg --passphrase-fd 0 -o $deckey \
	          --decrypt $key >/dev/null 2>&1 ); do
		echo -en "\nPassphrase for key $key: "
		read -s password <${CONSOLE:-/dev/tty}
		echo
		[ "$password" = "" ] && return 0
	done
	
	password=""
	umask $origumask
}

lo_setup () {
	# Set up loopback devices
	if test -f "$src" ; then
		test -d /sys/block/loop0 || modprobe loop || continue
		LOOP_ID=
		for i in 0 1 2 3 4 5 6 7 ; do
			if test "x`cat /sys/block/loop$i/size`" = "x0" ; then
				LOOP_ID=$i
				break
			fi
		done
		if test "x$LOOP_ID" = "x" ; then
			continue
		else
			$LOSETUP /dev/loop$LOOP_ID $src || continue
			src=/dev/loop$LOOP_ID
		fi
	fi
}

check_key () {
	if [ "x$key" != "x" ] && [ "x$key" != "xnone" ]; then
		INTERACTIVE="no"
		if test -e "$key" ; then
			MODE=`ls -l $key | sed 's/^....\(......\).*/\1/'`
			OWNER=`ls -l $key | sed 's/^[^ ]* *[^ ]* *\([^ ]*\).*/\1/'`

			# luks requires a persistent key, /dev/*random is not supported
			if test "x$USELUKS" = "xyes"; then
				if test "$key" = "/dev/urandom" || \
				   test "$key" = "/dev/hwrandom" || \
				   test "$key" = "/dev/random"; then
					echo -e "\n - LUKS does not work with random data as key, skipping" >&2
					continue
				fi
			fi
			if test "$MODE" != "------" && \
			   test "$key" != "/dev/urandom"  && \
			   test "$key" != "/dev/hwrandom" && \
			   test "$key" != "/dev/random"; then
				echo -e "\n - INSECURE MODE FOR $key" >&2
			fi
			if test $OWNER != root; then
				echo -e "\n - INSECURE OWNER FOR $key" >&2
			fi
		else
			echo -e "\n - Keyfile for '$dst' not found, skipping" >&2
			continue
		fi
		if [ "x$SSL" = "xyes" ]; then
			if [ -x /usr/bin/openssl ]; then
				decrypt_ssl && key=$deckey
			else
				echo -e "\n - Openssl is not available, skipping" >&2
				continue
			fi
		elif [ "x$GPG" = "xyes" ]; then
			if [ -x /usr/bin/gnupg ]; then
				decrypt_gpg && key=$deckey
			else
				echo -e "\n - Gnupg is not available, skipping" >&2
				continue
			fi
		fi
	else
		INTERACTIVE="yes"
		echo ""
	fi
}

do_luks () {
	if ! $CRYPTCMD isLuks $src >/dev/null 2>&1; then
		echo -e "\n - Device '$src' is not a LUKS partition, skipping" >&2
		return 1
	fi

	if test "x$KEYSCRIPT" != "x" ; then
		# FIXME: Add this once we're using cryptsetup 1.0.4
		# PARAMS="$PARAMS --key-file=-"
		$KEYSCRIPT $key <&1 | $CRYPTCMD $PARAMS luksOpen $src $dst
	else
		if test "x$INTERACTIVE" != "xyes" ; then
			PARAMS="$PARAMS --key-file=$key"
		fi
		$CRYPTCMD $PARAMS luksOpen $src $dst <&1
	fi

	if [ $? != 0 ]; then
		return 1
	fi

	if [ "$CHECK" != ""  ] && ! $CHECK $MAPPER/$dst $CHECKARGS; then
		echo -e "\n - the check for '$MAPPER/$dst' failed" >&2
		echo " - removing the crypto device $dst" >&2
		$CRYPTCMD luksClose $dst
		return 1
	fi

	return 0
}

do_noluks () {
	if [ "$PRECHECK" = "" ]; then
		PRECHECK="/lib/cryptsetup/checks/un_vol_id"
	fi

	if ($PRECHECK $src); then
		run=1
	elif ($PRECHECK $src swap) && test "$MAKESWAP" = "xyes"; then
		run=1
	else
		run=0
		echo -e "\n - the precheck for '$src' failed, skipping" >&2
		return 1
	fi
	
	if test "x$KEYSCRIPT" != "x" ; then
		# FIXME: Add this once we're using cryptsetup 1.0.4
		# PARAMS="$PARAMS --key-file=-"
		$KEYSCRIPT $key <&1 | $CRYPTCMD $PARAMS create $dst $src
	else
		if test "x$INTERACTIVE" != "xyes" ; then
			PARAMS="$PARAMS --key-file=$key"
		fi
		$CRYPTCMD $PARAMS create $dst $src <&1
	fi

	if [ $? != 0 ] ; then
		return 1
	fi


	if [ "$CHECK" != ""  ] && ! $CHECK $MAPPER/$dst $CHECKARGS; then
		echo -e "\n - the check for '$MAPPER/$dst' failed - maybe the password is wrong" >&2
		echo " - removing the crypto device $dst" >&2
		$CRYPTCMD remove $dst
		return 1
	fi

	return 0
}

mount_fs () {
	for point in $MOUNT; do
		mount $MOUNT 2>/dev/null 1>&2
		MOUNT_YES="yes"
	done
}

umount_fs () {
	if [ "x$MOUNT_YES" = "xyes" ]; then
		for point in $MOUNT; do
			umount $point
		done
	fi
}

do_swap () {
	if test "x$MAKESWAP" = "xyes" && test -b $MAPPER/$dst; then
		if $SWCHECK $MAPPER/$dst $SWCHECKARGS; then
			mkswap $MAPPER/$dst 2>/dev/null >/dev/null
		else
			echo -e "\n - the check for '$MAPPER/$dst' failed. $MAPPER/$dst contains data." >&2
			echo " - removing the crypto device $dst" >&2
			do_close
		fi
	fi
}

do_tmp () {
	if test "x$MAKETMP" = "xyes" && test -b $MAPPER/$dst; then
		mke2fs $MAPPER/$dst >/dev/null
		mount -t ext2 $MAPPER/$dst /tmp
		chmod 1777 /tmp
		umount /tmp
	fi
}

clean_keys () {
	if [ "$deckey" -a -f "$deckey" ]; then
		rm -f $deckey && deckey=""
	fi
}

do_close () {
	if echo $opt | grep -q "luks"; then
		$CRYPTCMD luksClose $dst
	else
		$CRYPTCMD remove $dst
	fi
}

do_start () {
	$DEVMAPCMD mknodes
	log_action_begin_msg "Starting $INITSTATE crypto disks"
	mount_fs
	egrep -v "^[[:space:]]*(#|$)" $TABFILE | while read dst src key opt; do

		# Make sure that all fields are present
		if [ "x$dst" = "x" ]; then
			continue
		elif [ "x$src" = "x" -o "x$key" = "x" -o "x$opt" = "x" ]; then
			log_progress_msg "$dst(skipped, missing parameters)"
			continue
		fi

		# Make sure source device exists
		if [ ! -r "$src" ]; then
			if [ "x$LOUD" = "xyes" ]; then
				log_progress_msg "$dst(skipped, device $src does not exist)"
			fi
			continue
		fi

		# Make sure that target device doesn't exist
		if [ -b $MAPPER/$dst ]; then
			log_progress_msg "$dst(running)"
			continue
		fi

		# All checks passed, do the real setup
		log_progress_msg "$dst(starting)"

		parse_opts
		check_key
		lo_setup

		if test "x$USELUKS" = "xyes" ; then
			do_luks
		else
			do_noluks
		fi

		if [ $? -ne 0 ]; then
			log_progress_msg "$dst(failed)"
		else
			do_swap
			do_tmp
		fi

		clean_keys
	done
	
	umount_fs
	log_action_end_msg 0
}

do_stop () {
	$DEVMAPCMD mknodes
	log_action_begin_msg "Stopping $INITSTATE crypto disks"
	egrep -v "^[[:space:]]*(#|$)" $TABFILE | while read dst src key opt; do
		if test -b $MAPPER/$dst; then
			if $DEVMAPCMD info $dst | grep -q '^Open count: *0$'; then
				dev=`$DEVMAPCMD table $dst | sed 's/^.* \([0-9]*:[0-9]*\) .*/\1/'`
				major=`echo $dev | sed 's/:.*//'`
				minor=`echo $dev | sed 's/.*://'`

				log_progress_msg "$dst(stopping)"
				do_close

				# Detach loopback device, if attached
				if test -f $src -a $major -eq 7; then
					$LOSETUP -d /dev/loop$minor
				fi
			else
				log_progress_msg "$dst(busy)"
			fi
		else
			log_progress_msg "$dst(stopped)"
		fi
	done

	log_action_end_msg 0
}

